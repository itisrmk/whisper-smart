name: Release DMG

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Version number without v prefix (e.g. 0.2.18)"
        required: true
        type: string
      channel:
        description: "Release channel"
        required: true
        default: "beta"
        type: choice
        options:
          - beta
          - production
      checklist_confirmed:
        description: "I confirm the release checklist has been completed"
        required: true
        default: false
        type: boolean
      notes:
        description: "Release notes"
        required: false
        type: string

permissions:
  contents: write

jobs:
  release:
    runs-on: macos-latest
    timeout-minutes: 45

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Release Gate
        run: bash scripts/release_gate.sh

      - name: Enforce Release Checklist Confirmation
        if: ${{ !inputs.checklist_confirmed }}
        run: |
          echo "Checklist confirmation is required before tagging a release."
          exit 1

      - name: Validate Production Notarization Secrets
        if: ${{ inputs.channel == 'production' }}
        env:
          CERT_P12: ${{ secrets.MACOS_CERTIFICATE_P12_BASE64 }}
          CERT_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          set -euo pipefail
          for var_name in CERT_P12 CERT_PASSWORD APPLE_ID APPLE_APP_SPECIFIC_PASSWORD APPLE_TEAM_ID; do
            value="${!var_name:-}"
            if [[ -z "$value" ]]; then
              echo "Missing required production secret: $var_name"
              exit 1
            fi
          done

      - name: Import Production Signing Certificate
        if: ${{ inputs.channel == 'production' }}
        uses: apple-actions/import-codesign-certs@v3
        with:
          p12-file-base64: ${{ secrets.MACOS_CERTIFICATE_P12_BASE64 }}
          p12-password: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}

      - name: Build Production-Signed DMG
        if: ${{ inputs.channel == 'production' }}
        env:
          VERSION: ${{ inputs.version }}
        run: |
          set -euo pipefail
          SIGNING_IDENTITY="$(security find-identity -v -p codesigning | grep 'Developer ID Application' | head -n 1 | sed -E 's/.*"([^"]+)".*/\1/' || true)"
          if [[ -z "$SIGNING_IDENTITY" ]]; then
            echo "Developer ID Application signing identity not found after certificate import."
            exit 1
          fi
          CODESIGN_IDENTITY="$SIGNING_IDENTITY" VERSION="$VERSION" bash scripts/package_dmg.sh

      - name: Notarize Production DMG
        if: ${{ inputs.channel == 'production' }}
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          set -euo pipefail
          DMG_PATH=".build/release/Whisper-Smart-mac.dmg"
          xcrun notarytool submit "$DMG_PATH" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_SPECIFIC_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait
          xcrun stapler staple "$DMG_PATH"

      - name: Resolve Previous Tag
        id: previous_tag
        env:
          VERSION: ${{ inputs.version }}
        run: |
          set -euo pipefail
          git fetch --tags --force
          CURRENT_TAG="v${VERSION}"
          PREVIOUS_TAG="$(git tag --sort=-v:refname | grep -v "^${CURRENT_TAG}$" | head -n 1 || true)"
          echo "value=${PREVIOUS_TAG}" >> "$GITHUB_OUTPUT"

      - name: Compose Release Notes
        id: release_notes
        env:
          VERSION: ${{ inputs.version }}
          INPUT_NOTES: ${{ inputs.notes }}
          PREVIOUS_TAG: ${{ steps.previous_tag.outputs.value }}
          REPOSITORY: ${{ github.repository }}
          CHANNEL: ${{ inputs.channel }}
        run: |
          set -euo pipefail
          NOTES_FILE="$(mktemp)"
          if [[ -n "${INPUT_NOTES}" ]]; then
            printf "%s\n\n" "${INPUT_NOTES}" >> "$NOTES_FILE"
          else
            printf "Automated DMG release for v%s.\n\n" "${VERSION}" >> "$NOTES_FILE"
          fi
          printf "Release channel: **%s**\n\n" "${CHANNEL}" >> "$NOTES_FILE"
          printf "Release artifact: \`.build/release/Whisper-Smart-mac.dmg\`\n\n" >> "$NOTES_FILE"
          if [[ -n "${PREVIOUS_TAG}" ]]; then
            printf "Rollback reference: https://github.com/%s/releases/tag/%s\n" "${REPOSITORY}" "${PREVIOUS_TAG}" >> "$NOTES_FILE"
          else
            printf "Rollback reference: none (first tagged release).\n" >> "$NOTES_FILE"
          fi
          echo "path=${NOTES_FILE}" >> "$GITHUB_OUTPUT"

      - name: Update Appcast
        env:
          VERSION: ${{ inputs.version }}
          NOTES_FILE: ${{ steps.release_notes.outputs.path }}
          REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail
          APP_PLIST=".build/release/Whisper Smart.app/Contents/Info.plist"
          DMG_PATH=".build/release/Whisper-Smart-mac.dmg"
          if [[ ! -f "$APP_PLIST" ]]; then
            echo "Missing built app plist at $APP_PLIST"
            exit 1
          fi
          if [[ ! -f "$DMG_PATH" ]]; then
            echo "Missing DMG at $DMG_PATH"
            exit 1
          fi

          BUILD_VERSION="$(/usr/libexec/PlistBuddy -c 'Print :CFBundleVersion' "$APP_PLIST")"
          SHORT_VERSION="$(/usr/libexec/PlistBuddy -c 'Print :CFBundleShortVersionString' "$APP_PLIST")"
          if [[ "$SHORT_VERSION" != "$VERSION" ]]; then
            echo "App short version ($SHORT_VERSION) does not match requested release version ($VERSION)"
            exit 1
          fi

          DMG_LENGTH="$(stat -f%z "$DMG_PATH")"
          DMG_URL="https://github.com/${REPOSITORY}/releases/download/v${VERSION}/Whisper-Smart-mac.dmg"
          PUB_DATE="$(LC_ALL=C date -u '+%a, %d %b %Y %H:%M:%S +0000')"

          bash scripts/update_appcast.sh \
            --version "$VERSION" \
            --build-version "$BUILD_VERSION" \
            --dmg-url "$DMG_URL" \
            --dmg-length "$DMG_LENGTH" \
            --notes-file "$NOTES_FILE" \
            --pub-date "$PUB_DATE" \
            --output "appcast.xml"

      - name: Commit + Push Appcast
        env:
          VERSION: ${{ inputs.version }}
        run: |
          set -euo pipefail
          if git diff --quiet -- appcast.xml; then
            echo "No appcast change to commit."
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add appcast.xml
          git commit -m "chore(release): update appcast for v${VERSION}"
          # Keep legacy Sparkle clients (old SUFeedURL -> master) receiving updates.
          git push origin HEAD:main HEAD:master

      - name: Create and Push Tag
        env:
          VERSION: ${{ inputs.version }}
        run: |
          set -euo pipefail
          TAG="v${VERSION}"
          if git rev-parse "${TAG}" >/dev/null 2>&1; then
            echo "Tag ${TAG} already exists locally."
          else
            git tag "${TAG}"
          fi
          if git ls-remote --tags origin "${TAG}" | grep -q "${TAG}"; then
            echo "Tag ${TAG} already exists on origin."
          else
            git push origin "${TAG}"
          fi

      - name: Publish GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ inputs.version }}
          name: v${{ inputs.version }}
          body_path: ${{ steps.release_notes.outputs.path }}
          files: |
            .build/release/Whisper-Smart-mac.dmg
            appcast.xml
